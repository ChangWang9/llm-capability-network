<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Capability Network</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 20px;
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }

        .main-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            margin: 10px 0 0 0;
            font-size: 1.1em;
            opacity: 0.8;
        }

        .controls {
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        .stats {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .legend {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        #network {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #network:active {
            cursor: grabbing;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 300px;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .tooltip h3 {
            margin: 0 0 8px 0;
            color: #4fc3f7;
        }

        .tooltip .papers {
            max-height: 150px;
            overflow-y: auto;
        }

        .tooltip .paper-item {
            margin-bottom: 4px;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.2em;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            stroke-width: 3px;
        }

        .link {
            transition: all 0.3s ease;
        }

        .link:hover {
            stroke-width: 3px !important;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <h1>LLM Capabilities</h1>
                <p class="subtitle">Network Visualization</p>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label for="fileInput">选择数据文件:</label>
                    <input type="file" id="fileInput" accept=".xlsx" style="margin-bottom: 15px;">
                </div>
                
                <div class="control-group">
                    <label for="minConnections">最小连接数: <span id="minConnectionsValue">1</span></label>
                    <input type="range" id="minConnections" min="1" max="50" value="1">
                </div>
                
                <div class="control-group">
                    <label for="minFrequency">最小频次: <span id="minFrequencyValue">10</span></label>
                    <input type="range" id="minFrequency" min="1" max="100" value="10">
                </div>
            </div>

            <div class="stats" id="stats">
                <h3>统计信息</h3>
                <div class="stat-item">
                    <span>节点数:</span>
                    <span id="nodeCount">-</span>
                </div>
                <div class="stat-item">
                    <span>边数:</span>
                    <span id="edgeCount">-</span>
                </div>
                <div class="stat-item">
                    <span>最大频次:</span>
                    <span id="maxFreq">-</span>
                </div>
            </div>

            <div class="legend">
                <h3>图例</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>高频能力 (>500)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4;"></div>
                    <span>中频能力 (100-500)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #45b7d1;"></div>
                    <span>低频能力 (<100)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(90deg, #666, #ccc);"></div>
                    <span>连接强度表示共现频次</span>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>正在加载数据...</div>
            </div>
            <svg id="network"></svg>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // 全局变量
        let processedData = null;
        let svg, g, simulation;
        let nodes = [], links = [];
        
        // 初始化
        async function init() {
            setupNetwork();
            setupFileInput();
            setupControls();
            document.getElementById('loading').innerHTML = '<div>请选择数据文件开始</div>';
        }

        // 加载数据
        async function loadData(file) {
            if (!file) {
                throw new Error('请选择数据文件');
            }
            
            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer);
            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
            const data = XLSX.utils.sheet_to_json(worksheet);

            const capabilityStats = {};
            const paperCapabilityMap = {};
            const capabilityPairMap = {};

            data.forEach((row) => {
                const paperName = row['Papers'];
                const mergedCapabilities = row['merged_capabilities'];
                
                if (mergedCapabilities && typeof mergedCapabilities === 'string') {
                    try {
                        let capabilities = [];
                        if (mergedCapabilities.startsWith('[') && mergedCapabilities.endsWith(']')) {
                            const cleanStr = mergedCapabilities.slice(1, -1);
                            if (cleanStr.trim()) {
                                capabilities = cleanStr.split(',').map(cap => cap.trim().replace(/^['"]|['"]$/g, ''));
                            }
                        } else {
                            capabilities = [mergedCapabilities];
                        }
                        
                        capabilities.forEach(cap => {
                            if (cap && cap.trim()) {
                                const cleanCap = cap.trim();
                                capabilityStats[cleanCap] = (capabilityStats[cleanCap] || 0) + 1;
                                
                                if (!paperCapabilityMap[cleanCap]) {
                                    paperCapabilityMap[cleanCap] = [];
                                }
                                if (paperName && !paperCapabilityMap[cleanCap].includes(paperName)) {
                                    paperCapabilityMap[cleanCap].push(paperName);
                                }
                            }
                        });
                        
                        for (let i = 0; i < capabilities.length; i++) {
                            for (let j = i + 1; j < capabilities.length; j++) {
                                const cap1 = capabilities[i].trim();
                                const cap2 = capabilities[j].trim();
                                if (cap1 && cap2) {
                                    const pairKey = [cap1, cap2].sort().join('|||');
                                    if (!capabilityPairMap[pairKey]) {
                                        capabilityPairMap[pairKey] = [];
                                    }
                                    if (paperName && !capabilityPairMap[pairKey].includes(paperName)) {
                                        capabilityPairMap[pairKey].push(paperName);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.log('解析错误:', e);
                    }
                }
            });

            processedData = {
                capabilityStats,
                paperCapabilityMap,
                capabilityPairMap
            };
        }

        // 设置网络图
        function setupNetwork() {
            const container = document.querySelector('.main-content');
            const width = container.clientWidth;
            const height = container.clientHeight;

            svg = d3.select('#network')
                .attr('width', width)
                .attr('height', height);

            g = svg.append('g');

            // 添加缩放和拖拽
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // 初始化力导向图
            simulation = d3.forceSimulation()
                .force('link', d3.forceLink().id(d => d.id).distance(d => Math.max(50, 200 - d.strength * 2)))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => d.radius + 5));
        }

        // 设置控件
        function setupControls() {
            const minConnectionsSlider = document.getElementById('minConnections');
            const minFrequencySlider = document.getElementById('minFrequency');

            minConnectionsSlider.addEventListener('input', () => {
                document.getElementById('minConnectionsValue').textContent = minConnectionsSlider.value;
                updateVisualization();
            });

            minFrequencySlider.addEventListener('input', () => {
                document.getElementById('minFrequencyValue').textContent = minFrequencySlider.value;
                updateVisualization();
            });
        }

        // 添加文件输入处理
        function setupFileInput() {
            const fileInput = document.getElementById('fileInput');
            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file) {
                    try {
                        document.getElementById('loading').classList.remove('hidden');
                        document.getElementById('loading').innerHTML = '<div class="spinner"></div><div>正在加载数据...</div>';
                        
                        await loadData(file);
                        updateVisualization();
                        document.getElementById('loading').classList.add('hidden');
                    } catch (error) {
                        console.error('数据加载失败:', error);
                        document.getElementById('loading').innerHTML = '<div>数据加载失败，请检查文件格式</div>';
                    }
                }
            });
        }

        // 更新可视化
        function updateVisualization() {
            const minConnections = parseInt(document.getElementById('minConnections').value);
            const minFrequency = parseInt(document.getElementById('minFrequency').value);

            // 过滤节点
            const filteredCapabilities = Object.entries(processedData.capabilityStats)
                .filter(([_, count]) => count >= minFrequency)
                .map(([name, count]) => ({ id: name, count }));

            // 创建节点
            nodes = filteredCapabilities.map(cap => ({
                id: cap.id,
                count: cap.count,
                radius: Math.sqrt(cap.count) * 2 + 8,
                color: getNodeColor(cap.count)
            }));

            // 创建边
            links = [];
            const nodeSet = new Set(nodes.map(n => n.id));

            Object.entries(processedData.capabilityPairMap).forEach(([pairKey, papers]) => {
                if (papers.length >= minConnections) {
                    const [cap1, cap2] = pairKey.split('|||');
                    if (nodeSet.has(cap1) && nodeSet.has(cap2)) {
                        links.push({
                            source: cap1,
                            target: cap2,
                            strength: papers.length,
                            papers: papers
                        });
                    }
                }
            });

            // 更新统计信息
            updateStats();

            // 渲染图
            renderNetwork();
        }

        // 获取节点颜色
        function getNodeColor(count) {
            if (count > 500) return '#ff6b6b';
            if (count > 100) return '#4ecdc4';
            return '#45b7d1';
        }

        // 更新统计信息
        function updateStats() {
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = links.length;
            document.getElementById('maxFreq').textContent = Math.max(...nodes.map(n => n.count));
        }

        // 渲染网络
        function renderNetwork() {
            // 清除现有元素
            g.selectAll('*').remove();

            // 创建链接
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', d => Math.sqrt(d.strength))
                .on('mouseover', showEdgeTooltip)
                .on('mouseout', hideTooltip);

            // 创建节点
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => d.radius)
                .attr('fill', d => d.color)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .on('mouseover', showNodeTooltip)
                .on('mouseout', hideTooltip)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // 添加标签
            const labels = g.append('g')
                .selectAll('text')
                .data(nodes.filter(d => d.count > 200))
                .enter().append('text')
                .text(d => d.id.replace(' capability', ''))
                .attr('font-size', '10px')
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .attr('dy', 4)
                .style('pointer-events', 'none');

            // 更新力导向图
            simulation.nodes(nodes);
            simulation.force('link').links(links);
            simulation.alpha(1).restart();

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                labels
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
        }

        // 工具提示函数
        function showNodeTooltip(event, d) {
            const papers = processedData.paperCapabilityMap[d.id] || [];
            const topPapers = papers.slice(0, 5);
            
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <h3>${d.id}</h3>
                <p><strong>出现次数:</strong> ${d.count}</p>
                <div class="papers">
                    <strong>相关论文 (前5篇):</strong><br>
                    ${topPapers.map(paper => `<div class="paper-item">${paper.replace('.txt', '')}</div>`).join('')}
                </div>
            `;
            
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
        }

        function showEdgeTooltip(event, d) {
            const topPapers = d.papers.slice(0, 5);
            
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <h3>${d.source.id} + ${d.target.id}</h3>
                <p><strong>共现次数:</strong> ${d.strength}</p>
                <div class="papers">
                    <strong>共同出现的论文 (前5篇):</strong><br>
                    ${topPapers.map(paper => `<div class="paper-item">${paper.replace('.txt', '')}</div>`).join('')}
                </div>
            `;
            
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // 拖拽函数
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // 窗口调整大小
        window.addEventListener('resize', () => {
            const container = document.querySelector('.main-content');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            svg.attr('width', width).attr('height', height);
            simulation.force('center', d3.forceCenter(width / 2, height / 2));
            simulation.alpha(0.3).restart();
        });

        // 启动应用
        init();
    </script>
</body>
</html>